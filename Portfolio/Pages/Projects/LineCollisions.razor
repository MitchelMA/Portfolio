@page "/line-collisions"
@using Portfolio.Model.Project
@using Portfolio.Model.Text
@layout ProjectLayout

@inject LightboxRegistry Registry
@inject AppState AppState
@inject ProjectState ProjectState
@inject ProjectInfoGetter Getter
@inject LanguageTable LanguageTable

@implements IDisposable

<PageIsland IslandTitle="Introductie" id="iductie">
    <ChildContent>
        <TwoView FlexValues="@(new("3 260px", "1 460px"))">
            <FirstView>
                <p>Line collisions zijn een hele belangrijke vorm/basis van collisions.</p>
                <hr/>
                <p>
                    Een vast regel bij line collisions is "Hoek van inval, is hoek van uitval".
                    Deze is het makkelijkst toe te passen bij perfecte horizontale of verticale lijnen.
                </p>
                <hr/>
                <p>
                    Een andere manier om dit te berekenen, is middels
                    <a
                        href="https://www.physicsclassroom.com/class/vectors/Lesson-1/Vector-Resolution"
                        target="_blank">
                        Vector Resolution
                    </a>
                    en lijkt heel erg op het berekenen van de
                    <a
                        href="https://www.mrchadd.nl/academy/vakken/wiskunde/de-richtingscoefficient"
                        target="_blank">
                        De Richtingscoëfficient
                    </a> van een lineare formule.
                </p>
            </FirstView>
            <SecondView>
                <article class="two-view__img-article">
                    <LightboxImg class="hover-scale sc05"
                                 src="./images/circle-line-2.png"
                                 alt="Hoek van inval, is hoek van uitval"
                                 height="250"
                                 BoundLightboxName="@nameof(LineCollisions)"
                                 Registry="Registry"/>
                    <LightboxImg class="hover-scale sc05"
                                 src="./images/vector-resolution.png"
                                 alt="Simpele uitwerking van Vector Resolution"
                                 height="250"
                                 BoundLightboxName="@nameof(LineCollisions)"
                                 Registry="Registry"/>
                </article>
            </SecondView>
        </TwoView>
    </ChildContent>
</PageIsland>

<PageIsland IslandTitle="Voorbeeld Uitwerking" id="uit" Inverse="true">
    <ChildContent>
        <TwoView FlexValues="@new("2 300px", "1 350px")">
            <FirstView>
                <p>
                    Een voorbeelduitwerking van hoe ik dit toegepast heb,
                    lijkt enorm op vector resolution. Alleen in mijn geval houdt het rekening met de hoek waronder
                    de lijn staat.
                </p>
                <hr/>
                <p>
                    Laten we beginnen met een lijn die onder een hoek van 45° staat, en
                    een bal die deze tegemoet komt met een richting van
                    <img src="images/math/line-collisions/vector_v.svg" alt="Vector v = [0.89; -0.44]" height="18" />.
                    De normal van de lijn is als volgt: 
                    <img src="images/math/line-collisions/vector_n.svg" alt="Vector n = [-0.71; 0.71]" height="18" />, 
                    ook hebben we een vector nodig
                    die de lijn navolgt: 
                    <img src="images/math/line-collisions/vector_a.svg" alt="Vector a = [0.71; 0.71]" height="18" />. 
                    Om met deze twee vectoren een "bounding-box"
                    te vormen, vermenigvuldigen we deze met de dotproduct. hieruit volgt weer een scalair,
                    dus vermenigvuldigen we hiervan de uitkomst weer met de corresponderende vector. Als voorbeeld de normal: <br/>
                    nieuwe normal (nn): <br/>
                    <img src="images/math/line-collisions/vector_nn_equation.svg" alt="Vector nn = [0.67, -0.67]" height="18" /> <br/>
                    nieuwe along (na): <br/>
                    <img src="images/math/line-collisions/vector_na_equation.svg" alt="Vector na = [0.23, 0.23]" height="18"/> <br/>
                    Nu hebben we een resolutie-vector van `v`, die rekening houdt met de normal van de lijn.
                    De nieuwe velocity `v` na impact wordt als volgt berekent: <br/>
                    <img src="images/math/line-collisions/vector_nv_equation.svg" alt="Vector nv = [-0.44, 0.89]" height="18"/>.
                </p>
            </FirstView>
            <SecondView>
                <article class="two-view__img-article sticky">
                    <LightboxImg class="hover-scale sc05"
                                 src="./images/resolution-process.png"
                                 alt="Resolution process"
                                 style="width: 100%;"
                                 BoundLightboxName="@nameof(LineCollisions)"
                                 Registry="Registry"/>
                </article>
            </SecondView>
        </TwoView>
    </ChildContent>
</PageIsland>

<PageIsland IslandTitle="Achterliggend Systeem" id="systeem">
    <TwoView FlexValues="@(new("2 450px", "1 450px"))">
        <FirstView>
            <p>
                Ik heb, als achterliggend systeem, een singleton gebouwd waar ik aan het begin van de scene
                alle lijnen bij kan registreren. Later tijdens het spelen, kan de bal checken bij deze singleton of
                hij in de buurt komt van een lijn. Hier kan hij de normal van de lijn opvragen en de richting van de lijn.
                Deze info is, zoals net aangegeven, nodig voor het berekenen van de nieuwe velocity na impact.
            </p>
            <hr/>
            <p>
                Ook heb ik, zoals je in het vorige plaatje kon zien, een `
                <a
                    href="https://github.com/MitchelMA/Line-collision/blob/revision/lineparts/Assets/Scripts/Utils/PqrForm.cs"
                    target="_blank">
                    PqrForm
                </a>` gemaakt. dit is een class
                die ik gebruik om wiskundige berekeningen te maken met de componenten p, q en r in de
                opbouw: `px + qy = r`.
                Ik kan met deze class de slope van een formule berekenen, de angle, ik kan de x ophalen met
                een gegeven y en andersom.. en nog veel meer.
            </p>
        </FirstView>
        <SecondView>
            <article class="two-view__img-article sticky">
                <LightboxImg class="hover-scale sc05"
                             src="./images/rider64_SUVtMKrW1o.png"
                             alt="De Add method in de singleton"
                             style="width:  100%;"
                             BoundLightboxName="@nameof(LineCollisions)"
                             Registry="Registry"/>
                
            </article>
        </SecondView>
    </TwoView>
</PageIsland>


<Lightbox LightboxName="@nameof(LineCollisions)"
          Registry="Registry"/>

@code {

    private static ProjectDataModel? _model;
    private static NavLinkData[]? _links; 

    protected override async Task OnInitializedAsync()
    {
        LanguageTable.LanguageChangedAsync += OnLanguageChanged;
        
        _model = await Getter.GetCorrespondingToUri();
        
        // project data
        ProjectState.PageEndGithub = _model?.GitHub;
        ProjectState.ProjectStatus = _model?.Status ?? ProjectStatus.Finished;

        await LanguageTable.AwaitLanguageContentAsync(SetLangData);
        
        // page details
        AppState.PageIcon = new PageIcon("image/png", "./images/Unity_AmCJ2pY4oC.png");
        AppState.ShowFooter = true;
    }
    
    private async Task OnLanguageChanged(object sender, int newCultureIdx) => await SetLangData(sender);

    private async Task SetLangData(object? sender)
    {
        var currentData = await LanguageTable.LoadAllCurrentPageData();
        if (currentData is null)
        {
            await Console.Error.WriteLineAsync("Couldn't get Page Data in specified language!");
            return;
        }

        SetPageContent(currentData);
    }

    private void SetPageContent(LangPageData langPageData)
    {
        SetHeaderData(langPageData.HeaderData!.Value);
        SetLinksData(langPageData.LinksData!.Value);
    }

    private void SetHeaderData(LangHeaderModel headerData)
    {
        var header = new HeaderData()
        {
            Title = headerData.Title,
            UnderTitle = headerData.UnderTitle,
            Description = headerData.Description,
            ImagePath = _model!.Value.Header.HeaderImage,
            ExtraStyles = null
        };
        AppState.HeaderData = header;
        AppState.PageTitleExtension = " " + headerData.PageTitleExtension;
    }

    private void SetLinksData(LangLinksModel linksData)
    {
        var l = linksData.Links.Length;
        _links = new NavLinkData[l];
        for (var i = 0; i < l; i++)
        {
            var cur = linksData.Links[i];
            _links[i] = new NavLinkData(cur.Href, cur.DisplayText, cur.OpensNew);
        }

        AppState.Links = _links;
        AppState.MinNonStackedSize = linksData.MinWidth;
    }

    public void Dispose()
    {
        LanguageTable.ManifestLoadedAsync -= SetLangData;
        LanguageTable.LanguageChangedAsync -= OnLanguageChanged;
    }
    
}