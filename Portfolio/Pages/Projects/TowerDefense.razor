@page "/towerdefense"
@using Portfolio.Client
@using Portfolio.Model.Project
@using Portfolio.Model.Text

@layout ProjectLayout

@inject AppState AppState
@inject ProjectInfoGetter Getter
@inject ProjectState ProjectState
@inject LightboxRegistry Registry
@inject LanguageTable LanguageTable

@implements IDisposable

<PageIsland IslandTitle="Introductie" id="iductie">
    <ChildContent>
        <TwoView 
            style="flex-wrap: wrap;"
            FlexValues="@(new("1 300px", "3 450px"))">
            <FirstView>
                <p>
                    In de eerste periode van het tweede jaar op deze studie, hadden wij
                    10 weken de tijd gekregen om aan een 
                    <a href="https://en.wikipedia.org/wiki/Tower_defense" target="_blank">tower defense</a>
                    spel te werken. <br/>
                    Het doel van deze opdracht was niet om een mooi uitziend spel te maken,
                    maar eerder het leren van implementeren van 
                    <a href="https://en.wikipedia.org/wiki/Game_mechanics" target="_blank">game mechanics</a>
                    (i.e. enemy-wave systeem; schieten van projectielen; etc..)
                </p>
            </FirstView>

            <SecondView>
                <article class="two-view__img-article">
                <LightboxImg src="./images/Unity_4xajzJxaDR.jpg"
                             alt="De map van het spel"
                             class="hover-scale sc05"
                             style="max-width: 100%;"
                             BoundLightboxName="@nameof(TowerDefense)"
                             Registry="Registry"/>
                </article>
            </SecondView>
        </TwoView>

    </ChildContent>
</PageIsland>

<PageIsland IslandTitle="Path Finding" id="path" Inverse="true">
    <ChildContent>
        <TwoView
            style="flex-wrap: wrap;"
            FlexValues="@(new("2 300px", "2 300px"))">
            
            <FirstView>
                Om enemies een pad af te kunnen laten lopen, is er een systeem nodig
                om aan te geven waar het pad is. <br/>
                Volgorde is alvolgt: een enemy wordt ingespawned; deze krijgt zijn eerste "target"
                doorgegeven. Wanneer deze bij zijn target is, vraagt de enemy aan zijn target wat
                de volgende target is. Het pad vormt op deze manier iets genaamd een
                <a href="https://en.wikipedia.org/wiki/Linked_list" target="_blank">Linked List</a>.
                <br/><br/>
                Het allermooiste van dit systeem is, is dat ik het ook voor de camera kan gebruiken.
                Meestal zie je wel wanneer je in een level komt; dat er een korte "cutscene" is waar
                het hele level wordt laten zien.
                Het pad van de cutscene kan ik maken middels het zelfde systeem wat ik gebruik voor
                de enemies.
            </FirstView>
            
            <SecondView>
                <article class="two-view__img-article">
                    <LightboxImg src="./images/PathFinding.png"
                                 alt="Visual sheet van path finding mechanic"
                                 class="hover-scale sc05"
                                 style="max-width: 100%;"
                                 BoundLightboxName="@nameof(TowerDefense)"
                                 Registry="Registry"/>
                </article>
            </SecondView>
            
        </TwoView>
    </ChildContent> 
</PageIsland>

<Lightbox LightboxName="@nameof(TowerDefense)"
          Registry="Registry"/>

@code {

    private static NavLinkData[]? _links;
    private static ProjectDataModel? _model;

    protected override async Task OnInitializedAsync()
    {
        LanguageTable.LanguageChangedAsync += OnLanguageChanged;
        
        _model = await Getter.GetCorrespondingToUri();

    // setup of the page details
        AppState.ShowFooter = true;
        AppState.PageIcon = StaticData.DefaultPageIcon;

        await LanguageTable.AwaitLanguageContentAsync(SetLangData);
        
        ProjectState.ProjectStatus = _model?.Status ?? ProjectStatus.Finished;
        ProjectState.PageEndGithub = _model?.GitHub;

    }
    
    private async Task OnLanguageChanged(object sender, int newCultureIdx) => await SetLangData(sender);

    private async Task SetLangData(object? sender)
    {
        var currentData = await LanguageTable.LoadAllCurrentPageData();
        if (currentData is null)
        {
            await Console.Error.WriteLineAsync("Couldn't get Page Data in specified language!");
            return;
        }

        SetPageContent(currentData);
    }

    private void SetPageContent(LangPageData langPageData)
    {
        SetHeaderData(langPageData.HeaderData!.Value);
        SetLinksData(langPageData.LinksData!.Value);
    }

    private void SetHeaderData(LangHeaderModel headerData)
    {
        var header = new HeaderData
        {
            Title = headerData.Title,
            UnderTitle = headerData.UnderTitle,
            Description = headerData.Description,
            ImagePath = _model!.Value.Header.HeaderImage,
            ExtraStyles = null
        };

        AppState.HeaderData = header;
        AppState.PageTitleExtension = " " + headerData.PageTitleExtension;
    }

    private void SetLinksData(LangLinksModel linksData)
    {
        var l = linksData.Links.Length;
        _links = new NavLinkData[l];
        for (var i = 0; i < l; i++)
        {
            var cur = linksData.Links[i];
            _links[i] = new NavLinkData(cur.Href, cur.DisplayText, cur.OpensNew);
        }

        AppState.Links = _links;
        AppState.MinNonStackedSize = linksData.MinWidth;
    }

    public void Dispose()
    {
        LanguageTable.ManifestLoadedAsync -= SetLangData;
        LanguageTable.LanguageChangedAsync -= OnLanguageChanged;
    }
    
}